---
title: Meta‑Transactions & Gasless USD₮0 Transfers
tags: [intermediate, quickstart]
authors: [vmmunoza]
description: Let your users send USD₮0 on Flare without holding FLR for gas. Learn how meta-transactions enable users to execute transactions without directly paying the associated gas fees.
keywords: [Gasless, USD₮0, Meta-Transactions]
sidebar_position: 9
---

import CodeBlock from "@theme/CodeBlock";
import Deposit from "!!raw-loader!/examples/developer-hub-javascript/GaslessApp.tsx";
import Withdraw from "!!raw-loader!/examples/developer-hub-javascript/GaslessRelayer.ts";

## Introduction

Flare’s USD₮0 integration delivers truly native, cross-chain USDT transfer on Flare with zero gas for end users. 
In this guide, you’ll learn how to set up a gasless transfer—also called a meta‑transaction. With this approach, users can move tokens without paying gas themselves; instead, a third party (for example, a relayer or the dApp owner) covers the fees on their behalf.

The gasless transfer of USD₮0 uses **EIP‑712** to structure and present transaction data for safe off‑chain signing, and **EIP‑3009** to extend ERC‑20 with `transferWithAuthorization(...)`, allowing a relayer to submit the signed payload on‑chain and cover the gas fee.

The USD₮0 contracts on Flare are:

‣ Proxy (The ERC-20 entrypoint): 0xe7cd86e13AC4309349F30B3435a9d337750fC82D

‣ The implementation: 0x779Ded0c9e1022225f8E0630b35a9b54bE713736

You can check the details of the verified contract on the [Flare Explorer](https://flare-explorer.flare.network/address/0x779Ded0c9e1022225f8E0630b35a9b54bE713736?tab=contract). 
Note that on this guide we use USD₮0 as an example, but a similar logic can apply for other assets as well.


## About EIP-3009

[EIP-3009](https://eips.ethereum.org/EIPS/eip-3009) adds meta‑transaction support to ERC‑20 tokens: instead of calling `transfer(...)` directly, a user signs a concise off‑chain authorization, then a relayer can submit that signature onchain via `transferWithAuthorization`, paying for the gas fees.
This pattern separates **authorization** (user intent) from **execution** (onchain relay). EIP-3009 adds two core functions:

- **`transferWithAuthorization(from, to, value, validAfter, validBefore, nonce, v, r, s)`**  
  Moves tokens from `from` to `to` if:
  - The signature `(v, r, s)` matches `from`  
  - The current time is between `validAfter` and `validBefore`  
  - `nonce` has not been used before  

- **`receiveWithAuthorization(from, to, value, validAfter, validBefore, nonce, v, r, s)`**  
  Similar to `transferWithAuthorization`, but allows a recipient or relayer to pull tokens from the signer’s balance—useful for collecting fees on receipt.

Both functions include **Timestamps** to prevent stale authorizations, and a **nonce** to prevent replay attacks.

Next, we’ll put theory into practice by wiring up a simple front‑end and relayer. The front‑end will craft a transfer message, have the user sign it in their wallet, and forward that signature to the relayer. 
The relayer will verify the signature, submit the corresponding onchain transaction, and pay the FLR gas fee on behalf of the user.


## Front‑End: Building & Signing Your Meta‑Transaction

In this section, you’ll see how to wire up your React app to build, sign, and relay an EIP‑3009 authorization payload. First, make sure you’ve set two environment variables in your `.env` (Vite will expose them as `import.meta.env.VITE_…`):

```dotenv
VITE_USD0_ADDRESS=0xe7cd86e13AC4309349F30B3435a9d337750fC82D   # the onchain USD₮0 token contract
VITE_RELAYER_URL=http://localhost:3000         # your relayer endpoint
```

With those in place, `App.tsx` can:

1. **Connect the wallet** (`window.ethereum`) and request an account.
2. **Instantiate** an `ethers.BrowserProvider` and `Signer`.
3. **Fetch** the token’s EIP‑712 domain (name, version, chainId, contract).
4. **Define** the `TransferWithAuthorization` typed‑data fields.
5. **Build** the payload object—serializing `value` to a string so it JSON‑encodes correctly, and setting a one‑hour validity window plus a fresh 32‑byte nonce.
6. **Call** `signer.signTypedData(domain, types, message)` to pop the wallet and produce a signature.
7. **Extract** `(v, r, s)` from that signature.
8. **POST** the JSON payload plus `(v, r, s)` to your relayer at `${VITE_RELAYER_URL}/relay-transfer`.

Below is a code snippet that you can copy‑paste into your React application:

<CodeBlock language="typescript" title="scripts/src/App.tsx">
  {Deposit}
</CodeBlock>


## Relayer: Submitting the Signed Transfer

Now let’s build the back‑end that turns the user’s signature into a real onchain transaction.  

The relayer is a small Express service that:

1. **Loads and validates environment variables** (`FLARE_RPC_URL`, `USD0_ADDRESS`, `RELAYER_PRIVATE_KEY`, `PORT`) via `dotenv/config`; exits early if anything is missing.
2. **Connects to Flare** with `JsonRpcProvider`, creates a `Wallet` from `RELAYER_PRIVATE_KEY`, and instantiates the USD₮0 `Contract` with that wallet so all calls are auto‑signed and the relayer pays gas.
3. **Spins up an Express server** with CORS and JSON parsing.
4. Exposes a simple **health‑check** at `GET /` to confirm the service is running.
5. Implements `POST /relay-transfer`, which:

   * Destructures `{ payload, v, r, s }` from the request body.
   * Calls `usd0.transferWithAuthorization(...)`, passing the six payload fields plus `v r s`, and sets an explicit `gasLimit` of `120_000`.
   * Waits for the transaction to mine, then returns `{ txHash }`; on error it returns `{ error }`.
6. **Starts listening** on `PORT` (default `3000`) and logs a success message.

Below is the code you'll need to implement this service:

<CodeBlock language="typescript" title="scripts/src/Relayer.ts">
  {Deposit}
</CodeBlock>
<br />

With this service running, your front‑end can POST the signed payload, and the relayer will execute the onchain transfer while covering the FLR gas fee.